/* The file is saved in UTF-8 codepage.
 * Check: «Stereotype», Section mark-§, Copyright-©, Alpha-α, Beta-β, Smile-☺.
 */
package cz.pecinovsky.english.lootp.town;

import cz.pecinovsky.english.lootp.manager.Controller;
import cz.pecinovsky.english.lootp.manager.CanvasManager;

import cz.pecinovsky.english.lootp.util.NamedColor;
import cz.pecinovsky.english.lootp.util.IO;
import cz.pecinovsky.english.lootp.util.Position;
import cz.pecinovsky.english.lootp.util.Size;
import cz.pecinovsky.english.lootp.util.Direction8;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;


/*******************************************************************************
 * Instances of the {@code Race} class represent races
 * that can be attended.
 * The race is characterized by the ring where the vehicles run.
 * This ring is created by a factory object passed to constructor in parameter.
 * The racers can subsequently register at the race.
 * All registered racers compete together in parallel,
 * each on its own ring instance.
 *
 * @author  Rudolf PECINOVSKÝ
 * @version 1.01.4240 — 2012-10-13
 */
public class ParallelRace implements IRace
{
    //== CONSTANT CLASS FIELDS =================================================

    /** Manager of the canvas on which the instance will be painted. */
    private static final CanvasManager CM = CanvasManager.getInstance();

    /** Default maximal available canvas width, where all the rings should fit.
     *  Each racer has a ring of its own and particular rings
     *  are separated with an empty column. */
    private static final int DEFAULT_MAX_CANVAS_WIDTH = 1000;

    /** Default maximal available canvas height, where should each ring fits. */
    private static final int DEFAULT_MAX_CANVAS_HEIGHT = 700;



    //== VARIABLE CLASS FIELDS =================================================

    /** Maximal available canvas width, where all the rings should fit.
     *  Each racer has a ring of its own
     *  and particular rings are separated with an empty column. */
    private static int maxCanvasWidth = DEFAULT_MAX_CANVAS_WIDTH;

    /** Maximal available canvas height, where the ring should fit. */
    private static int maxCanvasHeight = DEFAULT_MAX_CANVAS_HEIGHT;



    //== STATIC INITIALIZER (CLASS CONSTRUCTOR) ================================
    //== CONSTANT INSTANCE FIELDS ==============================================

    /** Map mapping the racer to the crate with information about this racer. */
    private final Map<IRacer, Info> racer2info = new HashMap<>();

    /** Number of rounds of the race. */
    private final int roundNumber;

    /** Factory generated the rings. */
    private final IRingFactory ringFactory;



    //== VARIABLE INSTANCE FIELDS ==============================================

    /** Currently set canvas module. */
    private int module;

    /** System time of the start. */
    private long time0;

    /** Number of registered racers. */
    private int racersNumber = 0;

    /** Number of columns and rows of the ring in use. */
    private int ringColumns, ringRows;



    //== CLASS GETTERS AND SETTERS =============================================
    //== OTHER NON-PRIVATE CLASS METHODS =======================================

    /***************************************************************************
     * Remember the maximal allowed canvas size.
     *
     * @param width  Max allowed pixel width
     * @param height Max allowed pixel height
     */
    public static void setMaxCanvasSize(int width, int height)
    {
        ParallelRace.maxCanvasWidth  = width;
        ParallelRace.maxCanvasHeight = height;
    }



    //##########################################################################
    //== CONSTUCTORS AND FACTORY METHODS =======================================

    /***************************************************************************
     * Creates an instance that will be able to organize
     * one ring race on rings generated by the given factory.
     *
     * @param ringFactory  Factory creating rings for the race
     */
    public ParallelRace(IRingFactory ringFactory)
    {
        this(ringFactory, 1);
    }


    /***************************************************************************
     * Creates an instance that will be able to organize race
     * with the given number of rounds on rings generated by the given factory.
     *
     * @param ringFactory  Factory creating rings for the race
     * @param roundNumber  Number of rounds of the race
     */
    public ParallelRace(IRingFactory ringFactory, int roundNumber)
    {
        this.ringFactory = ringFactory;
        this.roundNumber = roundNumber;
        this.module      = CM.getStep();    //Temporary value until the start
    }



    //== ABSTRACT METHODS ======================================================
    //== INSTANCE GETTERS AND SETTERS ==========================================
    //== OTHER NON-PRIVATE INSTANCE METHODS ====================================

    /***************************************************************************
     * Opens a dialog announcing start
     * and after closing it, starts measuring the time.
     */
    public void start()
    {
        Collection<Info> infos = racer2info.values();
        prepareCanvas();    //Sets it size so that the rings would just fit
        for (Info info : infos) {
            info.controller.start();
        }
        IO.inform("After confirming this window\n" +
                  "the time starts to be measured");
        time0 = System.currentTimeMillis();
    }


    /***************************************************************************
     * Finishes the race, terminates all registrations
     * and prepares for the new ones.
     */
    public void stop()
    {
        racer2info.clear();
    }


    /***************************************************************************
     * Registers the given racer, places it at the race start,
     * learns its needed keys
     * and registers its controller as a keyboard listener.
     *
     * @param racer Racer registering for the race
     */
    @Override
    public void register(IRacer racer)
    {
        if (racer2info.containsKey(racer)) {
            IO.inform("The racer cannot be registered twice: " + racer);
            return;
        }
        Ring       ring       = prepareNextRing(); //Modify number of racers
        RoadField  start      = ring.getStartField();
        RoadField  target     = start.getNext();
        Controller controller = Controller.createFor(racer);

        Info info = new Info(ring, start, target,
                             controller, roundNumber, racer);
        racer2info.put(racer, info);

        //Ensure, that both, racer as well as its ring, will be visible
        CM.add(ring);
        CM.addAbove(ring, racer);
    }


    /***************************************************************************
     * Checks that the racer reaches the right running target (checkpoint).
     * If yes, prepares the next target position, if no, does nothing.
     *
     * @param racer Racer announcing reaching the next position
     */
    @Override
    public void checkpoint(IRacer racer)
    {
        Info info = racer2info.get(racer);
        if (info == null) {
            return;                      //==========>
        }
        Position pz = racer.getPosition();
        Position pc = info.targetField.getPosition();
        if (pz.equals(pc)) {
            if (info.targetField == info.startField) {
                info.roundsLeft--;
                if (info.roundsLeft == 0) {
                    finishRace(racer, info);
                    return;                  //==========>
                }
            }
            info.targetField = info.targetField.getNext();
        }
    }


    /***************************************************************************
     * Returns a string representation of the object &ndash; its text signature.
     *
     * @return A string representation of the object
     */
    @Override
    public String toString()
    {
        return "ParallelRace(factory="      + ringFactory  +
                          ", racersNumber=" + racersNumber +
                          ", module="       + module       + ")";
    }



    //== PRIVATE AND AUXILIARY CLASS METHODS ===================================
    //== PRIVATE AND AUXILIARY INSTANCE METHODS ================================

    /***************************************************************************
     * Prepares the next ring and returns it.
     *
     * @return The requested ring
     */
    private Ring prepareNextRing()
    {
        int x = racersNumber * (ringColumns + 1) * module;
        Position position = new Position(x, 0);
        Ring     ring     = ringFactory.createRing(position,
                                 NamedColor.getNamedColor(racersNumber));
        racersNumber++;
        if (racersNumber == 1) {
            Size ringFieldSize = ring.getFieldSize();
            ringColumns = ringFieldSize.width;
            ringRows    = ringFieldSize.height;
        }
        return ring;
    }


    /***************************************************************************
     * Finishes the race for the given racer.
     *
     * @param racer Racer finishing the race
     * @param info  Crate with information about racer
     */
    private void finishRace(IRacer racer, Info info)
    {
        long now = System.currentTimeMillis();
        info.controller.stop();
        int time = (int)(now - time0 + 50) / 100;
        System.out.println("The racer " + racer.getName() +
               " finished the race in the time " +
               time/10 + "," + time%10 + " second");
        racer2info.remove(racer);
        if (racer2info.isEmpty()) {
            System.out.println("Race finished");
        }
    }


    /***************************************************************************
     * Prepares the canvas so that all rings just fit in it.
     */
    private void prepareCanvas()
    {
        int  canvasColumns  = (ringColumns + 1) * racersNumber  -  1;
        int  xStep  = maxCanvasWidth  / canvasColumns;
        int  yStep  = maxCanvasHeight / ringRows;
        this.module = Math.min(xStep, yStep);
        CM.setStepAndSize(module, canvasColumns, ringRows);

        CM.stopPainting(); {
            Collection<Info> infos = racer2info.values();
            for (Info info : infos) {
                Ring ring = info.ring;
                ring.setModule(module);
                CM.add(ring);
                info.racer.setDirection(ring.getStartField().getDirection());
                info.racer.setPosition (ring.getStartField().getPosition());
                info.racer.setModule(module);
            }
        } CM.returnPainting();
    }



    //== MEMBER DATA TYPES =====================================================

    /***************************************************************************
     * Internal crate containing the basic needed information
     * about racer and its current state.
     */
    private static class Info
    {
        /** Ring, where the race takes place. */
        private final Ring ring;

        /** The corresponding racer. */
        private final IRacer racer;

        /** Controller mediating the control from a keyboard. */
        private final Controller controller;

        /** The starting (and also finishing) field. */
        private final RoadField startField;

        /** The next running target field with a checkpoint
         *  checking, if the racer really runs through it. */
        private RoadField targetField;

        /** Number of remaining rounds. */
        private int roundsLeft;


        /***********************************************************************
         * Defines a new crate and initializes its fields.
         *
         * @param ring         Ring, where the race takes place
         * @param startField   The starting (and also finishing) field
         * @param targetField  The first checkpoint
         * @param controller   Controller, mediating the control from a keyboard
         * @param roundsNumber Number of rounds
         * @param racer        Racer, information of which the crate holds
         */
        Info(Ring ring, RoadField startField, RoadField targetField,
             Controller controller, int roundsNumber,
             IRacer racer)
        {
            this.ring       = ring;
            this.startField = startField;
            this.targetField= targetField;
            this.controller = controller;
            this.roundsLeft = roundsNumber;
            this.racer      = racer;
        }
    }



    //== TESTING CLASSES AND METHODS ===========================================

    /***************************************************************************
     * The test method.
     */
    public static void test()
    {
        int racers = 4;
        int size   = racers * 100;
        int rounds = 2;
        ParallelRace.setMaxCanvasSize(size, size);
        IRingFactory iFact = new OShapeRingFactory(2, 2, Direction8.SOUTH);
        ParallelRace race  = new ParallelRace(iFact, rounds);

        for (int i=1;   i <= racers;   i++) {
            Arrow  arrow = new Arrow(0, 0, NamedColor.WHITE);
            Vehicle_B vb = new Vehicle_B(arrow);
            vb.setName(NamedColor.getNamedColor(i-1).getName());
            vb.registerFor(race);
        }
        race.start();
    }
    //    /** @param args Command line arguments - not used. */
    //    public static void main(String[] args)  {  test();  }
}
